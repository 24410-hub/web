<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>고전 로그라이크: 던전 탐험</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc, collection, query, orderBy, limit, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global variables provided by the environment
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        let app, db, auth, userId;

        // Function to initialize Firebase and authenticate
        window.initializeFirebase = async () => {
            if (!firebaseConfig) {
                console.error("Firebase config is missing. Firestore will be disabled.");
                return;
            }
            try {
                // setLogLevel('Debug'); // Enable for debugging
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await signInAnonymously(auth);
                }

                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        userId = user.uid;
                        console.log("Authenticated with userId:", userId);
                    } else {
                        // Use a fallback random ID if authentication fails or is anonymous
                        userId = crypto.randomUUID();
                        console.log("Signed out or anonymous. Using temporary userId:", userId);
                    }
                    window.db = db; // Make db and userId available globally for game logic
                    window.userId = userId;
                    // Trigger game setup once auth is ready
                    window.gameSetupReady = true;
                    if (window.onFirebaseReady) {
                        window.onFirebaseReady();
                    }
                });

            } catch (error) {
                console.error("Firebase initialization or authentication failed:", error);
            }
        };

        // Call initialization on script load
        window.initializeFirebase();
    </script>
    <style>
        /* 고전 로그라이크 느낌을 위한 폰트와 배경 */
        @import url('https://fonts.googleapis.com/css2?family=D2+Coding:wght@400;700&display=swap');
        :root {
            --bg-color: #0d1117; /* GitHub Dark Mode Background */
            --text-color: #c9d1d9; /* Light Gray Text */
            --accent-color: #58a6ff; /* Blue Accent */
            --red-color: #f85149;
        }
        body {
            font-family: 'D2 Coding', monospace;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 0;
            user-select: none;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        .main-container {
            width: 95vw;
            max-width: 1200px;
            height: 95vh;
            border: 1px solid #30363d;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
            padding: 1rem;
        }
        .screen {
            display: none;
        }
        .map-cell {
            font-size: 1rem;
            line-height: 1;
            text-align: center;
            cursor: default;
        }
        .status-overlay {
            z-index: 100;
            background-color: rgba(0, 0, 0, 0.95);
            border: 2px solid var(--accent-color);
            box-shadow: 0 0 20px var(--accent-color);
            min-width: 500px;
        }
        .log-message {
            padding: 0.1rem 0;
            border-bottom: 1px dotted #30363d;
        }
        .log-message:last-child {
            border-bottom: none;
        }
        .barbarian-slow {
            animation: slow-move 1s infinite alternate;
        }
        @keyframes slow-move {
            from { opacity: 1; }
            to { opacity: 0.7; }
        }
        /* 색상 매핑 */
        .color-wall { color: #8b8b8b; } /* 벽 */
        .color-arrow { color: #f9d71c; } /* 화살 */
        .color-down { color: #ff6347; } /* 계단 */
        .color-item { color: #76ff03; } /* 아이템 */
        .color-player { color: #58a6ff; } /* 캐릭터 */
        .color-empty { color: #444; } /* 공백 */
        .color-monster-bat { color: #a970ff; }
        .color-monster-goblin { color: #00b894; }
        .color-monster-orc { color: var(--red-color); }
        .color-monster-zombie { color: #95a5a6; }
        .color-monster-spider { color: #e67e22; }
        .color-monster-harpy { color: #f39c12; }
        .color-monster-wolf { color: #7f8c8d; }
        .color-monster-durahan { color: var(--red-color); }
        .color-monster-medusa { color: var(--red-color); }
        .color-monster-arachne { color: var(--red-color); }
        .color-monster-oni { color: var(--red-color); }
        .color-monster-yeti { color: var(--red-color); }
        .color-monster-vampire { color: var(--red-color); }
        .color-shop { color: #ffc0cb; } /* 상점 */
    </style>
</head>
<body>

    <div id="game-container" class="main-container rounded-lg">
        <!-- 메인 메뉴 화면 -->
        <div id="mainMenuScreen" class="screen flex flex-col items-center justify-center h-full">
            <h1 class="text-4xl font-bold mb-12 text-green-400">고전 로그라이크 던전</h1>
            <div id="mainMenuOptions" class="text-2xl space-y-4">
                <div id="optionStart" class="cursor-pointer p-2 border-2 border-transparent hover:border-accent-color transition duration-150" data-action="start">▶ 시작</div>
                <div id="optionHallOfFame" class="cursor-pointer p-2 border-2 border-transparent hover:border-accent-color transition duration-150" data-action="hallOfFame">명예의 전당</div>
                <div id="optionExit" class="cursor-pointer p-2 border-2 border-transparent hover:border-accent-color transition duration-150" data-action="exit">종료</div>
            </div>
            <p class="text-sm mt-8 text-gray-500">W/S (또는 ↑/↓) 로 메뉴를 이동하고 Enter로 선택하세요.</p>
        </div>

        <!-- 캐릭터 생성 화면 -->
        <div id="charCreationScreen" class="screen flex flex-col items-center justify-center h-full p-8">
            <h2 class="text-3xl font-bold mb-8 text-accent-color">새로운 모험가 등록</h2>
            <div id="charCreationForm" class="w-full max-w-md space-y-4">
                <div>
                    <label class="block mb-1 text-lg">이름:</label>
                    <input type="text" id="playerNameInput" class="w-full p-2 bg-gray-800 border border-gray-600 rounded" maxlength="15" value="모험가">
                </div>

                <div class="flex justify-between items-center p-2 border-2 border-transparent" data-field="gender">
                    <label class="text-lg">성별:</label>
                    <div id="genderSelect" data-value="남자" class="flex space-x-4">
                        <span class="cursor-pointer hover:text-green-400" data-option="남자">[남자]</span>
                        <span class="cursor-pointer text-gray-500" data-option="여자">여자</span>
                    </div>
                </div>

                <div class="flex justify-between items-center p-2 border-2 border-transparent" data-field="weapon">
                    <label class="text-lg">주무기:</label>
                    <div id="weaponSelect" data-value="검" class="flex space-x-2">
                        <span class="cursor-pointer hover:text-green-400" data-option="검">[검]</span>
                        <span class="cursor-pointer text-gray-500" data-option="단검">단검</span>
                        <span class="cursor-pointer text-gray-500" data-option="둔기">둔기</span>
                        <span class="cursor-pointer text-gray-500" data-option="활">활</span>
                        <span class="cursor-pointer text-gray-500" data-option="마법 무기">마법 무기</span>
                    </div>
                </div>

                <div class="flex justify-between items-center p-2 border-2 border-transparent" data-field="race">
                    <label class="text-lg">종족:</label>
                    <div id="raceSelect" data-value="인간" class="flex space-x-4">
                        <span class="cursor-pointer hover:text-green-400" data-option="인간">[인간]</span>
                        <span class="cursor-pointer text-gray-500" data-option="엘프">엘프</span>
                        <span class="cursor-pointer text-gray-500" data-option="바바리안">바바리안</span>
                    </div>
                </div>

                <button id="startGameButton" class="w-full mt-8 p-3 bg-green-700 hover:bg-green-600 rounded transition duration-150 text-white font-bold" data-action="confirmChar">던전 입장</button>
            </div>
            <p class="text-sm mt-4 text-gray-500">W/S (또는 ↑/↓) 로 필드를 이동하고 Enter/Space로 옵션을 변경하세요.</p>
        </div>

        <!-- 명예의 전당 화면 -->
        <div id="hallOfFameScreen" class="screen h-full p-8 overflow-auto">
            <h2 class="text-3xl font-bold mb-8 text-yellow-400">명예의 전당</h2>
            <div id="hallOfFameList" class="space-y-2">
                <!-- 명예의 전당 데이터가 여기에 로드됩니다 -->
                <p class="text-gray-500">데이터 로딩 중...</p>
            </div>
            <button id="backToMenuFromHall" class="mt-8 p-2 bg-gray-700 hover:bg-gray-600 rounded transition duration-150 text-white font-bold">메인 메뉴로 돌아가기</button>
        </div>

        <!-- 게임 화면 -->
        <div id="gameScreen" class="screen flex-grow flex space-x-4">
            <!-- 지도 영역 -->
            <div id="mapArea" class="flex-grow flex flex-col">
                <div id="mapContainer" class="flex-grow bg-black p-2 overflow-auto whitespace-pre rounded-lg border border-gray-700 text-base leading-none">
                    <!-- 맵이 렌더링될 곳 -->
                </div>
            </div>

            <!-- 상태 및 로그 영역 -->
            <div class="w-80 flex flex-col space-y-4">
                <div id="currentStatus" class="bg-gray-800 p-4 rounded-lg border border-gray-700">
                    <h3 class="text-xl font-bold mb-2 text-accent-color">상태 정보</h3>
                    <div id="statusInfo" class="text-sm space-y-1">
                        <p>이름: <span id="statName">N/A</span></p>
                        <p>층수: <span id="statFloor">1</span>층</p>
                        <p>Lv: <span id="statLv">1</span></p>
                        <p>HP: <span id="statHP">20</span>/<span id="statMaxHP">20</span></p>
                        <p>마력: <span id="statMP">0</span></p>
                        <p>갈증: <span id="statThirst">100</span> | 배고픔: <span id="statHunger">100</span></p>
                        <hr class="border-gray-700 my-1">
                        <p>근력(STR): <span id="statStr">1</span></p>
                        <p>민첩(AGI): <span id="statAgi">1</span></p>
                        <p>방어(DEF): <span id="statDef">1</span></p>
                        <p>마력(MAG): <span id="statMag">1</span></p>
                        <hr class="border-gray-700 my-1">
                        <p>화살: <span id="statArrows">0</span></p>
                        <p>골드: <span id="statGold">0</span> G</p>
                    </div>
                    <p class="text-xs mt-2 text-gray-500">TAB 키로 상세 상태창을 엽니다.</p>
                </div>

                <div id="gameLog" class="bg-gray-800 p-4 rounded-lg border border-gray-700 flex-grow overflow-y-auto max-h-96">
                    <h3 class="text-xl font-bold mb-2 text-red-400">로그</h3>
                    <div id="logMessages" class="text-xs space-y-1">
                        <!-- 로그 메시지가 여기에 추가됩니다 -->
                    </div>
                </div>
            </div>
        </div>

        <!-- 상태창 오버레이 (TAB) -->
        <div id="statusOverlay" class="status-overlay fixed inset-0 m-auto hidden p-8 rounded-lg">
            <h2 class="text-2xl font-bold mb-4 text-accent-color">상태 & 인벤토리 (ESC/TAB으로 닫기)</h2>
            <div class="grid grid-cols-2 gap-4 h-[90%] overflow-y-auto">
                <!-- 좌측: 상세 상태 -->
                <div>
                    <div id="overlayStats" class="space-y-2 border-b pb-4 border-gray-700">
                        <p class="text-lg">이름: <span id="osName"></span> (Lv <span id="osLv"></span>)</p>
                        <p>성별: <span id="osGender"></span> | 종족: <span id="osRace"></span></p>
                        <p>HP: <span id="osHP"></span> | 마력: <span id="osMP"></span></p>
                        <p class="text-yellow-500">갈증: <span id="osThirst"></span> | 배고픔: <span id="osHunger"></span></p>
                        <hr class="border-gray-700 my-1">
                        <p>근력(STR): <span id="osStr" class="text-green-400"></span></p>
                        <p>민첩(AGI): <span id="osAgi" class="text-green-400"></span></p>
                        <p>방어(DEF): <span id="osDef" class="text-green-400"></span></p>
                        <p>마력(MAG): <span id="osMag" class="text-green-400"></span></p>
                    </div>

                    <div id="overlayEquipment" class="mt-4 space-y-2">
                        <h4 class="font-bold text-lg text-red-400">장비</h4>
                        <p>주무기: <span id="eqWeapon"></span></p>
                        <p>머리: <span id="eqHead"></span></p>
                        <p>몸통: <span id="eqBody"></span></p>
                        <p>심장(정수 슬롯 3): <span id="eqHeart"></span></p>
                        <p>손가락(반지 슬롯 4): <span id="eqFinger"></span></p>
                        <hr class="border-gray-700 my-1">
                        <p>화살 보유량: <span id="osArrows"></span></p>
                        <p>골드 보유량: <span id="osGold"></span> G</p>
                    </div>
                </div>

                <!-- 우측: 인벤토리 -->
                <div>
                    <h4 class="font-bold text-lg text-green-400">아이템 목록 (I키로 사용)</h4>
                    <ul id="inventoryList" class="space-y-1 text-sm mt-2">
                        <!-- 인벤토리 아이템이 여기에 로드됩니다 -->
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <!-- JavaScript Game Logic -->
    <script>
        // =========================================================
        // 1. 게임 데이터 및 상수 정의 (Korean)
        // =========================================================

        const GAME_MAP_SIZE = 25; // 맵 크기 (25x25)
        const BASE_INVENTORY_SIZE = 10;
        const LOG_MAX_MESSAGES = 50;

        const RACES = {
            '인간': { hp_bonus: 0, str: 1, agi: 1, def: 1, mag: 1, desc: "모든 스텟 +1, HP 25% 이하시 데미지 +2" },
            '엘프': { hp_bonus: 0, str: 0, agi: 5, def: 0, mag: 0, desc: "민첩 +5, 활 사거리 +1" },
            '바바리안': { hp_bonus: 8, str: 5, agi: 0, def: 0, mag: 0, desc: "HP +8, 근력 +5, 가끔 2턴 소모, 마법 사용 불가" }
        };

        const WEAPON_DATA = {
            '낡은 나무검': { type: '검', dmg: 1.0, special: '35% 주변 공격' },
            '철검과 방패': { type: '검', dmg: 2.3, def: 2, special: '35% 주변 공격, 방어 +2' },
            '미스릴 롱소드': { type: '검', dmg: 4.0, special: '35% 주변 공격' },
            // ... (다른 무기 목록은 데이터 구조만 정의하고 상세 로직은 생략)
            '나무 활': { type: '활', dmg: 12, no_arrow_dmg: 1, special: '화살 소모' },
            '혹한의 도끼 크라이오스': { type: '둔기', dmg: 12, special: '25% 마비, 확률적 빙결(2턴 스턴)' },
        };

        const ARMOR_DATA = {
            '가죽 투구': { slot: '머리', def: 1 },
            '철 투구': { slot: '머리', def: 3 },
            '미스릴 갑옷': { slot: '몸통', def: 6.5 },
        };

        const ESSENCE_DATA = {
            '박쥐(B)': { grade: 9, str: 0, agi: 3, def: -4, hp: 0, dmg: 0, passive: '민첩 +3, 방어 -4' },
            '오크(O)': { grade: 6, str: 0, agi: -20, def: 9, hp: 20, dmg: 8, passive: '방어 +9, HP +20, 데미지 +8, 턴당 10% 확률로 마력 1 소모, HP 1 회복, 20% 확률로 2턴당 1 행동' },
            '아라크네(A)': { grade: 1, str: 20, agi: 20, def: 20, hp: 0, dmg: 20, skill: '확정 독 부여' },
        };

        const CONSUMABLE_DATA = {
            '빵': { type: '음식', hunger: 40, thirst: 0, desc: '배고픔 40 회복' },
            '물': { type: '음료', hunger: 0, thirst: 40, desc: '갈증 40 회복' },
            '구급 수술 키트': { type: '회복', hp_percent: 0.60, desc: 'HP 60% 회복' },
            '힘 물약': { type: '물약', stat: 'str', amount: 1, desc: '근력 1 증가 (영구)' },
            '모험가의 가방': { type: '가방', inv_slots: 12, desc: '아이템 보관공간 +12 (사용 시)' },
        };

        const MONSTER_DATA = {
            '박쥐': { symbol: 'B', color: 'color-monster-bat', hp: 5, dmg: 2, agi: 5, essence: '박쥐(B)' },
            '고블린': { symbol: 'G', color: 'color-monster-goblin', hp: 7, dmg: 3, agi: 1, essence: '고블린(G)' },
            '오크': { symbol: 'O', color: 'color-monster-orc', hp: 40, dmg: 8, agi: 0, turns_per_action: 2, essence: '오크(O)' },
            '뱀파이어': { symbol: 'V', color: 'color-monster-vampire', hp: 40, dmg: 10, agi: 19, essence: '뱀파이어(V)' },
        };

        const FLOORS = [
            // 1~5층
            { min: 1, max: 4, monsters: ['박쥐', '고블린'], shop_chance: 0.2 },
            { floor: 5, boss: '오크', monsters: ['박쥐', '고블린'], special: 'boss' },
            // 6~10층
            { min: 6, max: 9, monsters: ['좀비', '거미'], shop_chance: 0.2 },
            { floor: 10, boss: '하피', monsters: ['좀비', '거미'], special: 'boss' },
            // ... (나머지 층 정보는 구조만 정의하고 생략)
            { floor: 50, boss: '예티', special: 'boss' },
        ];


        // =========================================================
        // 2. 게임 상태 변수
        // =========================================================
        let gameState = {
            screen: 'mainMenu',
            menuIndex: 0,
            charCreationIndex: 0,
            currentFloor: 1,
            map: [], // 2D array of map objects
            entities: [], // Player and monsters
            log: [],
            isOverlayOpen: false,
            isGameRunning: false,
        };

        let player = {
            name: '모험가',
            gender: '남자',
            race: '인간',
            weaponType: '검',
            lv: 1,
            maxHp: 20,
            hp: 20,
            mp: 0,
            thirst: 100,
            hunger: 100,
            str: 1,
            agi: 1,
            def: 1,
            mag: 1,
            x: 0,
            y: 0,
            arrows: 10,
            gold: 0,
            equipment: {
                head: null,
                body: null,
                heart: [null, null, null],
                finger: [null, null, null, null],
                weapon: null
            },
            inventory: [], // { name: '빵', count: 1 }
            maxInventory: BASE_INVENTORY_SIZE,
            isBarbarianSlowed: false,
        };

        // =========================================================
        // 3. 유틸리티 및 UI 헬퍼
        // =========================================================

        /** 로그 메시지를 추가하고 UI에 렌더링합니다. */
        function addLog(message, color = 'var(--text-color)') {
            gameState.log.push({ message, color });
            if (gameState.log.length > LOG_MAX_MESSAGES) {
                gameState.log.shift();
            }
            renderLog();
        }

        /** 로그 UI를 업데이트합니다. */
        function renderLog() {
            const logElement = document.getElementById('logMessages');
            logElement.innerHTML = gameState.log.map(item =>
                `<p class="log-message" style="color: ${item.color}">${item.message}</p>`
            ).reverse().join(''); // 최신 로그가 위에 오도록
            logElement.scrollTop = logElement.scrollHeight; // 스크롤을 맨 아래로 이동
        }

        /** 화면을 전환합니다. */
        function setScreen(screenId) {
            document.querySelectorAll('.screen').forEach(el => el.style.display = 'none');
            const newScreen = document.getElementById(screenId);
            if (newScreen) {
                newScreen.style.display = 'flex';
                gameState.screen = screenId;
                gameState.menuIndex = 0; // 메뉴 인덱스 초기화
                gameState.charCreationIndex = 0;
            }
        }

        // =========================================================
        // 4. 메인 메뉴 및 캐릭터 생성
        // =========================================================

        /** 메인 메뉴를 렌더링하고 키 이벤트를 설정합니다. */
        function renderMainMenu() {
            const options = document.querySelectorAll('#mainMenuOptions div');
            options.forEach((opt, index) => {
                opt.classList.remove('border-accent-color', 'border-2', 'text-accent-color');
                if (index === gameState.menuIndex) {
                    opt.classList.add('border-accent-color', 'border-2', 'text-accent-color');
                    opt.innerHTML = `► ${opt.textContent.replace('► ', '')}`;
                } else {
                    opt.classList.remove('text-accent-color');
                    opt.innerHTML = opt.textContent.replace('► ', '');
                }
            });
        }

        /** 캐릭터 생성 폼을 렌더링하고 키 이벤트를 설정합니다. */
        function renderCharCreation() {
            const fields = document.querySelectorAll('#charCreationForm > div[data-field], #startGameButton');
            fields.forEach((field, index) => {
                if (field.id === 'startGameButton') {
                    field.classList.remove('border-accent-color', 'border-2');
                    if (index === gameState.charCreationIndex) {
                        field.classList.add('border-accent-color', 'border-2');
                    }
                    return;
                }

                field.classList.remove('border-accent-color', 'border-2');
                const selects = field.querySelector('div[data-value]');
                if (selects) {
                    const currentValue = selects.getAttribute('data-value');
                    selects.querySelectorAll('span').forEach(span => {
                        span.classList.remove('text-green-400');
                        span.classList.add('text-gray-500');
                        span.textContent = span.textContent.replace('[', '').replace(']', '');
                        if (span.getAttribute('data-option') === currentValue) {
                            span.classList.add('text-green-400');
                            span.classList.remove('text-gray-500');
                            span.textContent = `[${span.textContent}]`;
                        }
                    });
                }

                if (index === gameState.charCreationIndex) {
                    field.classList.add('border-accent-color', 'border-2');
                }
            });
        }

        /** 선택 옵션을 다음/이전으로 변경합니다. */
        function changeCharOption(field, direction) {
            const selectDiv = document.querySelector(`div[data-field="${field}"] div[data-value]`);
            if (!selectDiv) return;

            const options = Array.from(selectDiv.querySelectorAll('span')).map(s => s.getAttribute('data-option'));
            let currentIndex = options.indexOf(selectDiv.getAttribute('data-value'));
            currentIndex = (currentIndex + direction + options.length) % options.length;
            selectDiv.setAttribute('data-value', options[currentIndex]);
            renderCharCreation();
        }

        /** 최종 캐릭터 생성 및 게임 시작 */
        function startGame() {
            const nameInput = document.getElementById('playerNameInput');
            const genderSelect = document.getElementById('genderSelect');
            const weaponSelect = document.getElementById('weaponSelect');
            const raceSelect = document.getElementById('raceSelect');

            player.name = nameInput.value.trim() || '이름 없음';
            player.gender = genderSelect.getAttribute('data-value');
            player.weaponType = weaponSelect.getAttribute('data-value');
            player.race = raceSelect.getAttribute('data-value');

            // 기본 스탯 설정 및 종족 보너스 적용
            const raceBonus = RACES[player.race];
            player.str = 1 + raceBonus.str;
            player.agi = 1 + raceBonus.agi;
            player.def = 1 + raceBonus.def;
            player.mag = 1 + raceBonus.mag;
            player.maxHp = 20 + raceBonus.hp_bonus;
            player.hp = player.maxHp;

            // 초기 장비 및 인벤토리 설정
            player.equipment.weapon = { name: `${player.weaponType} (시작)`, type: player.weaponType, dmg: 0, special: '시작 무기' };
            player.inventory.push({ name: '빵', count: 3 });
            player.inventory.push({ name: '물', count: 3 });
            player.arrows = 10;
            player.gold = 50;
            player.lv = 1;
            gameState.currentFloor = 1;

            setScreen('gameScreen');
            gameState.isGameRunning = true;
            addLog(`** ${player.name} (${player.race})님, 던전에 입장합니다. **`, 'var(--accent-color)');
            generateFloor(gameState.currentFloor);
            renderGame();
        }


        // =========================================================
        // 5. 맵 및 게임 렌더링
        // =========================================================

        /** 단순 맵 생성 함수 (플레이어와 계단만 배치) */
        function generateFloor(floor) {
            const size = GAME_MAP_SIZE;
            gameState.map = [];
            gameState.entities = [];

            // 맵을 벽으로 초기화
            for (let y = 0; y < size; y++) {
                gameState.map[y] = [];
                for (let x = 0; x < size; x++) {
                    gameState.map[y][x] = { symbol: '#', color: 'color-wall', passable: false };
                }
            }

            // 임시로 하나의 큰 방 생성 및 랜덤 오브젝트 배치
            const roomSize = Math.floor(size * 0.7);
            const startX = Math.floor((size - roomSize) / 2);
            const startY = Math.floor((size - roomSize) / 2);

            for (let y = startY; y < startY + roomSize; y++) {
                for (let x = startX; x < startX + roomSize; x++) {
                    gameState.map[y][x] = { symbol: '.', color: 'color-empty', passable: true };
                }
            }

            // 플레이어 시작 위치 (중앙)
            player.x = startX + Math.floor(roomSize / 2);
            player.y = startY + Math.floor(roomSize / 2);
            gameState.map[player.y][player.x] = { symbol: '@', color: 'color-player', passable: false };

            // 계단 배치 (랜덤 위치)
            let stairsX, stairsY;
            do {
                stairsX = startX + Math.floor(Math.random() * roomSize);
                stairsY = startY + Math.floor(Math.random() * roomSize);
            } while (stairsX === player.x && stairsY === player.y);

            gameState.map[stairsY][stairsX] = { symbol: '$', color: 'color-down', passable: true, type: 'stairs' };

            // 몬스터 배치 (임시)
            const floorData = FLOORS.find(f => f.floor === floor || (floor >= f.min && floor <= f.max)) || FLOORS[0];
            const monsterList = floorData.monsters || [];
            const numMonsters = Math.min(20, Math.floor(Math.random() * 10) + 1); // 최대 20마리
            for (let i = 0; i < numMonsters; i++) {
                const monsterName = monsterList[Math.floor(Math.random() * monsterList.length)];
                const data = MONSTER_DATA[monsterName];
                let monX, monY;
                do {
                    monX = startX + Math.floor(Math.random() * roomSize);
                    monY = startY + Math.floor(Math.random() * roomSize);
                } while (!gameState.map[monY][monX].passable || gameState.map[monY][monX].symbol !== '.');

                gameState.entities.push({
                    name: monsterName,
                    ...data,
                    x: monX,
                    y: monY,
                    hp: data.hp,
                    maxHp: data.hp,
                });
                gameState.map[monY][monX] = { symbol: data.symbol, color: data.color, passable: false, type: 'monster', entityIndex: gameState.entities.length - 1 };
            }

            addLog(`** ${floor}층에 도달했습니다. **`, 'var(--red-color)');
        }

        /** 지도와 UI를 렌더링합니다. */
        function renderMap() {
            const mapContainer = document.getElementById('mapContainer');
            if (gameState.screen !== 'gameScreen') return;

            let html = '';
            for (let y = 0; y < GAME_MAP_SIZE; y++) {
                for (let x = 0; x < GAME_MAP_SIZE; x++) {
                    const cell = gameState.map[y][x];
                    html += `<span class="map-cell ${cell.color}">${cell.symbol}</span>`;
                }
                html += '\n'; // 줄바꿈
            }
            mapContainer.innerHTML = html;
        }

        /** 상태창 (우측 패널)을 렌더링합니다. */
        function renderStats() {
            if (gameState.screen !== 'gameScreen') return;

            document.getElementById('statName').textContent = player.name;
            document.getElementById('statFloor').textContent = gameState.currentFloor;
            document.getElementById('statLv').textContent = player.lv;
            document.getElementById('statHP').textContent = Math.max(0, player.hp);
            document.getElementById('statMaxHP').textContent = player.maxHp;
            document.getElementById('statMP').textContent = player.mp;
            document.getElementById('statThirst').textContent = player.thirst;
            document.getElementById('statHunger').textContent = player.hunger;

            // 스탯
            document.getElementById('statStr').textContent = player.str;
            document.getElementById('statAgi').textContent = player.agi;
            document.getElementById('statDef').textContent = player.def;
            document.getElementById('statMag').textContent = player.mag;

            document.getElementById('statArrows').textContent = player.arrows;
            document.getElementById('statGold').textContent = player.gold;
        }

        /** 모든 게임 요소를 렌더링합니다. */
        function renderGame() {
            renderMap();
            renderStats();
        }

        /** TAB 상태창 오버레이를 렌더링합니다. */
        function renderStatusOverlay() {
            if (gameState.screen !== 'gameScreen' || !gameState.isOverlayOpen) {
                document.getElementById('statusOverlay').classList.add('hidden');
                return;
            }
            document.getElementById('statusOverlay').classList.remove('hidden');

            // 상태 정보 업데이트
            document.getElementById('osName').textContent = player.name;
            document.getElementById('osLv').textContent = player.lv;
            document.getElementById('osGender').textContent = player.gender;
            document.getElementById('osRace').textContent = player.race;
            document.getElementById('osHP').textContent = `${Math.max(0, player.hp)} / ${player.maxHp}`;
            document.getElementById('osMP').textContent = player.mp;
            document.getElementById('osThirst').textContent = player.thirst;
            document.getElementById('osHunger').textContent = player.hunger;

            document.getElementById('osStr').textContent = player.str;
            document.getElementById('osAgi').textContent = player.agi;
            document.getElementById('osDef').textContent = player.def;
            document.getElementById('osMag').textContent = player.mag;

            // 장비 정보
            document.getElementById('eqWeapon').textContent = player.equipment.weapon ? player.equipment.weapon.name : '없음';
            document.getElementById('eqHead').textContent = player.equipment.head ? player.equipment.head.name : '없음';
            document.getElementById('eqBody').textContent = player.equipment.body ? player.equipment.body.name : '없음';
            document.getElementById('eqHeart').textContent = player.equipment.heart.map(e => e ? e.name : '비어 있음').join(', ');
            document.getElementById('eqFinger').textContent = player.equipment.finger.map(r => r ? r.name : '비어 있음').join(', ');

            document.getElementById('osArrows').textContent = player.arrows;
            document.getElementById('osGold').textContent = player.gold;

            // 인벤토리 목록
            const inventoryList = document.getElementById('inventoryList');
            inventoryList.innerHTML = player.inventory.map((item, index) =>
                `<li class="p-1 hover:bg-gray-700 cursor-pointer" data-index="${index}">${item.name} (${item.count})</li>`
            ).join('');
        }

        // =========================================================
        // 6. 플레이어 행동 및 게임 턴
        // =========================================================

        /** 이동 로직 */
        function movePlayer(dx, dy) {
            const newX = player.x + dx;
            const newY = player.y + dy;

            if (newX < 0 || newX >= GAME_MAP_SIZE || newY < 0 || newY >= GAME_MAP_SIZE) return;

            const targetCell = gameState.map[newY][newX];

            // 1. 벽 체크
            if (!targetCell.passable && targetCell.symbol === '#') {
                addLog('벽에 부딪혔습니다.', 'gray');
                return;
            }

            // 2. 몬스터 체크 (전투)
            if (targetCell.type === 'monster') {
                startCombat(targetCell.entityIndex);
                return;
            }

            // 3. 계단 체크 (다음 층 이동)
            if (targetCell.type === 'stairs' && targetCell.symbol === '$') {
                goToNextFloor();
                return;
            }

            // 4. 아이템 체크 (줍기)
            if (targetCell.symbol === '%' || targetCell.symbol === ')') {
                pickUpItem(newX, newY, targetCell);
            }

            // 이전 위치 업데이트
            gameState.map[player.y][player.x] = { symbol: '.', color: 'color-empty', passable: true };

            // 새 위치 업데이트
            player.x = newX;
            player.y = newY;
            gameState.map[player.y][player.x] = { symbol: '@', color: 'color-player', passable: false };

            // 턴 진행
            playerTurn();
        }

        /** 플레이어 턴 로직 */
        function playerTurn() {
            // 바바리안 2턴 소모 로직 (저확률)
            if (player.race === '바바리안' && Math.random() < 0.05) {
                addLog('바바리안 종족 특성으로 인해 움직이는데 2턴이 소모됩니다.', 'var(--red-color)');
                player.isBarbarianSlowed = true;
            } else {
                player.isBarbarianSlowed = false;
            }

            // 갈증/배고픔 소모
            player.thirst = Math.max(0, player.thirst - 1);
            player.hunger = Math.max(0, player.hunger - 1);

            if (player.thirst === 0) { addLog('갈증으로 인해 힘이 약해집니다.', 'red'); }
            if (player.hunger === 0) { addLog('배고픔으로 인해 힘이 약해집니다.', 'red'); }

            renderGame();
            if (!player.isBarbarianSlowed) {
                monsterTurn();
            } else {
                // 바바리안 슬로우는 다음 턴에 몬스터 턴을 건너뛰지 않고 플레이어만 느려지게 처리할 수도 있지만,
                // 여기서는 몬스터 턴을 한 번 더 실행하도록 구현합니다.
                monsterTurn();
            }
        }

        /** 몬스터 턴 로직 */
        function monsterTurn() {
            const activeMonsters = gameState.entities.filter(e => e.hp > 0);
            activeMonsters.forEach(monster => {
                // 몬스터 AI (단순히 플레이어 방향으로 1칸 이동 시도)
                const dx = Math.sign(player.x - monster.x);
                const dy = Math.sign(player.y - monster.y);
                const newX = monster.x + dx;
                const newY = monster.y + dy;

                if (newX === player.x && newY === player.y) {
                    // 공격
                    performAttack(monster, player);
                } else {
                    // 이동
                    if (gameState.map[newY] && gameState.map[newY][newX] && gameState.map[newY][newX].passable) {
                        gameState.map[monster.y][monster.x] = { symbol: '.', color: 'color-empty', passable: true };
                        monster.x = newX;
                        monster.y = newY;
                        gameState.map[newY][newX] = { symbol: monster.symbol, color: monster.color, passable: false, type: 'monster', entityIndex: gameState.entities.indexOf(monster) };
                    }
                }
            });
            renderGame();
        }

        /** 전투 로직 (공격) */
        function performAttack(attacker, target) {
            const isPlayerAttacking = (attacker === player);

            let baseDmg = isPlayerAttacking ? player.str + (player.equipment.weapon ? player.equipment.weapon.dmg : 1) : attacker.dmg;

            // 플레이어 종족 특성: 인간 HP 25% 이하 보너스
            if (isPlayerAttacking && player.race === '인간' && player.hp / player.maxHp <= 0.25) {
                baseDmg += 2;
                addLog('인간 종족의 피의 분노가 발동했습니다!', 'red');
            }

            // 방어력에 의한 데미지 감소 로직
            let finalDmg = baseDmg;
            const defStat = target.def || 0;
            const defenseChance = Math.min(0.8, defStat * 0.05); // 방어 확률 (최대 80%)
            const defenseReduction = defStat * 0.5; // 방어 감소량

            if (Math.random() < defenseChance) {
                finalDmg = Math.max(1, baseDmg - defenseReduction);
                addLog(`${target.name}의 방어력이 ${defenseReduction.toFixed(1)} 데미지를 막았습니다!`, 'gray');
            }

            finalDmg = Math.ceil(finalDmg);

            target.hp -= finalDmg;
            addLog(`${attacker.name}가 ${target.name}에게 ${finalDmg}의 피해를 입혔습니다.`, isPlayerAttacking ? 'yellow' : 'red');

            if (target.hp <= 0) {
                if (target === player) {
                    gameOver();
                } else {
                    monsterDefeated(target);
                }
            }
        }

        /** 몬스터 처치 로직 */
        function monsterDefeated(monster) {
            addLog(`${monster.name}를 처치했습니다!`, 'green');
            
            // 맵에서 몬스터 제거
            gameState.map[monster.y][monster.x] = { symbol: '.', color: 'color-empty', passable: true };
            gameState.entities = gameState.entities.filter(e => e !== monster);

            // 레벨업 (단순화: 몬스터 처치 시 경험치 증가로 간주)
            player.lv++;
            player.maxHp += 1;
            player.hp += 1; // 회복

            // 랜덤 스탯 증가
            const stats = ['str', 'agi', 'def', 'mag'];
            const randomStat = stats[Math.floor(Math.random() * stats.length)];
            player[randomStat]++;
            addLog(`Lv이 올랐습니다! HP +1, ${randomStat} +1!`, 'yellow');

            // 정수 드랍 (10% 확률)
            if (Math.random() < 0.1 && monster.essence) {
                const essenceName = monster.essence;
                if (player.inventory.length < player.maxInventory) {
                    player.inventory.push({ name: essenceName, count: 1, type: 'essence' });
                    addLog(`[${essenceName}] 정수를 획득했습니다!`, 'yellow');
                } else {
                    addLog(`정수를 획득했지만 인벤토리가 가득 찼습니다.`, 'red');
                }
            }

            renderGame();
        }

        /** 아이템 줍기 로직 */
        function pickUpItem(x, y, cell) {
            let itemName;
            if (cell.symbol === '%') {
                itemName = '빵'; // 임시 아이템
            } else if (cell.symbol === ')') {
                itemName = '화살';
            }

            if (itemName === '화살') {
                player.arrows += 1;
                addLog('화살을 획득했습니다.', 'yellow');
            } else if (player.inventory.length < player.maxInventory) {
                const existing = player.inventory.find(i => i.name === itemName);
                if (existing) {
                    existing.count++;
                } else {
                    player.inventory.push({ name: itemName, count: 1 });
                }
                addLog(`[${itemName}]을(를) 획득했습니다.`, 'yellow');
            } else {
                addLog('인벤토리가 가득 찼습니다. 아이템을 놓아두었습니다.', 'red');
                return; // 아이템을 줍지 못했으므로 맵에서 제거하지 않음
            }

            // 맵에서 아이템 제거
            gameState.map[y][x] = { symbol: '.', color: 'color-empty', passable: true };
            renderGame();
        }

        /** 다음 층으로 이동 로직 */
        function goToNextFloor() {
            gameState.currentFloor++;
            if (gameState.currentFloor > 50) {
                gameWin();
                return;
            }
            addLog(`다음 층 (${gameState.currentFloor}층)으로 이동합니다.`, 'var(--accent-color)');
            generateFloor(gameState.currentFloor);
            renderGame();
        }

        /** 게임 오버 */
        function gameOver() {
            gameState.isGameRunning = false;
            addLog(`** 당신은 ${gameState.currentFloor}층에서 쓰러졌습니다. **`, 'var(--red-color)');
            // 명예의 전당 등록 (Firestore)
            saveHallOfFame(player.name, gameState.currentFloor);
            setTimeout(() => {
                alert(`게임 오버! ${player.name}님은 ${gameState.currentFloor}층까지 도달했습니다.`);
                setScreen('mainMenuScreen');
                renderMainMenu();
            }, 500);
        }

        /** 게임 승리 */
        function gameWin() {
            gameState.isGameRunning = false;
            addLog(`** 50층을 클리어하고 던전을 탈출했습니다! 축하합니다! **`, 'var(--accent-color)');
            saveHallOfFame(player.name, 50, true);
            setTimeout(() => {
                alert(`게임 클리어! ${player.name}님은 던전의 끝에 도달했습니다!`);
                setScreen('mainMenuScreen');
                renderMainMenu();
            }, 500);
        }


        // =========================================================
        // 7. 명예의 전당 (Firestore)
        // =========================================================

        /** 명예의 전당에 점수를 저장합니다. */
        async function saveHallOfFame(name, floor, isWin = false) {
            if (!window.db || !window.userId) {
                addLog('Firestore가 준비되지 않아 명예의 전당에 등록할 수 없습니다.', 'red');
                return;
            }

            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
            const hofCollectionRef = collection(window.db, `artifacts/${appId}/public/data/hallOfFame`);
            const timestamp = new Date();
            const scoreDocRef = doc(hofCollectionRef);

            try {
                await setDoc(scoreDocRef, {
                    name: name,
                    floor: floor,
                    isWin: isWin,
                    race: player.race,
                    timestamp: timestamp.toISOString(),
                });
                addLog('명예의 전당에 기록되었습니다.', 'green');
            } catch (e) {
                console.error("Error saving Hall of Fame: ", e);
                addLog('명예의 전당 저장 실패.', 'red');
            }
        }

        /** 명예의 전당 데이터를 불러와 렌더링합니다. */
        async function loadHallOfFame() {
            setScreen('hallOfFameScreen');
            const listEl = document.getElementById('hallOfFameList');
            listEl.innerHTML = '<p class="text-gray-500">데이터 로딩 중...</p>';

            if (!window.db) {
                listEl.innerHTML = '<p class="text-red-400">데이터베이스 연결 실패. Firestore가 준비되지 않았습니다.</p>';
                return;
            }

            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
            const hofCollectionRef = collection(window.db, `artifacts/${appId}/public/data/hallOfFame`);
            const q = query(hofCollectionRef, orderBy("floor", "desc"), limit(10));

            try {
                const querySnapshot = await getDocs(q);
                let listHtml = '';
                if (querySnapshot.empty) {
                    listHtml = '<p>아직 기록된 모험가가 없습니다.</p>';
                } else {
                    querySnapshot.forEach((doc, index) => {
                        const data = doc.data();
                        const winText = data.isWin ? ' (클리어)' : '';
                        listHtml += `<div class="p-2 bg-gray-700 rounded-md text-sm">
                            <span class="text-yellow-300 font-bold">${index + 1}. ${data.name}</span>
                            (${data.race}, ${new Date(data.timestamp).toLocaleDateString('ko-KR')})
                            <span class="float-right text-lg">${data.floor}층${winText}</span>
                        </div>`;
                    });
                }
                listEl.innerHTML = listHtml;
            } catch (e) {
                console.error("Error loading Hall of Fame: ", e);
                listEl.innerHTML = '<p class="text-red-400">명예의 전당 데이터를 불러오지 못했습니다.</p>';
            }
        }

        // =========================================================
        // 8. 키보드 이벤트 핸들러
        // =========================================================

        document.addEventListener('keydown', (e) => {
            if (gameState.isOverlayOpen) {
                if (e.key === 'Tab' || e.key === 'Escape') {
                    e.preventDefault();
                    gameState.isOverlayOpen = false;
                    renderStatusOverlay();
                }
                return;
            }

            if (gameState.screen === 'mainMenu') {
                const options = document.querySelectorAll('#mainMenuOptions div');
                if (e.key === 'w' || e.key === 'W' || e.key === 'ArrowUp') {
                    e.preventDefault();
                    gameState.menuIndex = (gameState.menuIndex - 1 + options.length) % options.length;
                    renderMainMenu();
                } else if (e.key === 's' || e.key === 'S' || e.key === 'ArrowDown') {
                    e.preventDefault();
                    gameState.menuIndex = (gameState.menuIndex + 1) % options.length;
                    renderMainMenu();
                } else if (e.key === 'Enter') {
                    e.preventDefault();
                    const action = options[gameState.menuIndex].getAttribute('data-action');
                    if (action === 'start') {
                        setScreen('charCreationScreen');
                        renderCharCreation();
                    } else if (action === 'hallOfFame') {
                        loadHallOfFame();
                    } else if (action === 'exit') {
                        alert('게임 종료 (실제 환경에서는 웹페이지를 닫습니다.)');
                    }
                }
            } else if (gameState.screen === 'charCreationScreen') {
                const fields = document.querySelectorAll('#charCreationForm > div[data-field], #startGameButton');
                const currentField = fields[gameState.charCreationIndex];

                if (e.key === 'w' || e.key === 'W' || e.key === 'ArrowUp') {
                    e.preventDefault();
                    gameState.charCreationIndex = (gameState.charCreationIndex - 1 + fields.length) % fields.length;
                    renderCharCreation();
                } else if (e.key === 's' || e.key === 'S' || e.key === 'ArrowDown') {
                    e.preventDefault();
                    gameState.charCreationIndex = (gameState.charCreationIndex + 1) % fields.length;
                    renderCharCreation();
                } else if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    const fieldType = currentField.getAttribute('data-field');
                    if (fieldType) {
                        changeCharOption(fieldType, 1);
                    } else if (currentField.id === 'startGameButton') {
                        startGame();
                    }
                }
            } else if (gameState.screen === 'gameScreen' && gameState.isGameRunning) {
                const key = e.key.toLowerCase();
                if (key === 'w' || key === 'arrowup') { e.preventDefault(); movePlayer(0, -1); }
                else if (key === 's' || key === 'arrowdown') { e.preventDefault(); movePlayer(0, 1); }
                else if (key === 'a' || key === 'arrowleft') { e.preventDefault(); movePlayer(-1, 0); }
                else if (key === 'd' || key === 'arrowright') { e.preventDefault(); movePlayer(1, 0); }
                else if (key === 'tab') {
                    e.preventDefault();
                    gameState.isOverlayOpen = !gameState.isOverlayOpen;
                    renderStatusOverlay();
                }
                // R, H, B, K, Y 키 등의 특수 동작은 여기에 추가 구현
                else if (key === 'r') { addLog('Ranged 공격 모드 (미구현)', 'gray'); }
                else if (key === 'i') { addLog('아이템 사용 (미구현)', 'gray'); }
            }
        });

        // =========================================================
        // 9. 초기화 및 시작
        // =========================================================

        window.onFirebaseReady = () => {
             // 초기 화면 설정
            setScreen('mainMenuScreen');
            renderMainMenu();
        };

        // UI 이벤트 리스너 (마우스 클릭)
        document.getElementById('startGameButton').addEventListener('click', startGame);
        document.getElementById('backToMenuFromHall').addEventListener('click', () => {
            setScreen('mainMenuScreen');
            renderMainMenu();
        });
        document.getElementById('optionStart').addEventListener('click', () => {
            setScreen('charCreationScreen');
            renderCharCreation();
        });
        document.getElementById('optionHallOfFame').addEventListener('click', loadHallOfFame);

        // 초기 맵 크기 설정
        window.addEventListener('resize', renderGame);

    </script>
</body>
</html>
